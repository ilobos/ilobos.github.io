[{"id":"5a84c1282747741be433f8b364c5c86f","title":"Mybatis Plus逻辑删除时自动填充时间","content":"\n1、背景开发规范里面要求有 delte_time 字段，但是baomidou的Mybatis plus里面没有这个字段；理论上也是不需要这个字段的，毕竟逻辑删除 与 update_time 配合起来就是 delte_time 的含义了；所以我们需要来研究一下 如何增加这个字段，并实现自动填充。\n2、开发环境java -version\njava version \"1.8.0_212\"\nJava(TM) SE Runtime Environment (build 1.8.0_212-b10)\nJava HotSpot(TM) 64-Bit Server VM (build 25.212-b10, mixed mode)\n&lt;dependency>\n    &lt;groupId>com.baomidou&lt;/groupId>\n    &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n    &lt;version>3.2.0&lt;/version>\n&lt;/dependency>\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.6&lt;&#x2F;version&gt;\n    &lt;relativePath&#x2F;&gt;\n&lt;&#x2F;parent&gt;\n\n3、通用字段1、SQL脚本：\n`id` bigint(32) unsigned NOT NULL AUTO_INCREMENT,\n`create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间',\n`update_time` timestamp NULL DEFAULT NULL COMMENT '更新时间',\n`delete_time` timestamp NULL DEFAULT NULL COMMENT '删除时间',\n`is_deleted` tinyint(4) unsigned NOT NULL DEFAULT '0' COMMENT '逻辑删除标识位',\n`version` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '版本号',\n2、对应的BaseModel.java\n@TableId(value = \"id\", type = IdType.AUTO)\nprotected Long id;\n\n@TableField(value = \"create_time\", fill = FieldFill.INSERT)\nprotected Date createTime;\n\n@TableField(value = \"update_time\", fill = FieldFill.UPDATE)\nprotected Date updateTime;\n\n@TableField(value = \"delete_time\")\nprotected Date deleteTime;\n\n@TableLogic\n@TableField(value = \"is_deleted\")\nprotected Integer isDeleted;\n\n@Version\n@TableField(value = \"version\", fill = FieldFill.UPDATE, update = \"%s+1\")\nprotected Integer version;\n@TableId：主键字段\n@Version：版本号字段\n@TableLogic：逻辑删除字段\nFieldFill.UPDATE：当更新时填充\nFieldFill.INSERT：当插入时填充\n根据SQL脚本和BaseModel的相关字段，我们可以发现并没有对各个时间字段进行特殊处理，这里是有一个专门的【自动填充控制器】来操作的；\n4、自定义填充控制器@Configuration\npublic class MybatisPlusMetaObjectHandler implements MetaObjectHandler &#123;\n\n    @Override\n    public void insertFill(MetaObject metaObject) &#123;\n        Date now = new Date();\n        // 注意此处字段名称需要使用驼峰\n        Object createdAt = this.getFieldValByName(\"createTime\", metaObject);\n        if (null == createdAt) &#123;\n            this.setFieldValByName(\"createTime\", now, metaObject);\n        &#125;\n\n        Object updatedAt = this.getFieldValByName(\"updateTime\", metaObject);\n        if (null == updatedAt) &#123;\n            this.setFieldValByName(\"updateTime\", now, metaObject);\n        &#125;\n\n        Object version = this.getFieldValByName(\"version\", metaObject);\n        if (null == version) &#123;\n            this.setFieldValByName(\"version\", 0L, metaObject);\n        &#125;\n    &#125;\n\n    @Override\n    public void updateFill(MetaObject metaObject) &#123;\n\n        Object updatedAt = this.getFieldValByName(\"updateTime\", metaObject);\n        if (null == updatedAt) &#123;\n            this.setFieldValByName(\"updateTime\", new Date(), metaObject);\n        &#125;\n\n        Object version = this.getFieldValByName(\"version\", metaObject);\n        if (null == version) &#123;\n            this.setFieldValByName(\"version\", 0L, metaObject);\n        &#125;\n    &#125;\n&#125;\n到了这一步，逻辑删除时并不能对新增的 delete_time 字段设置当前的时间，还不符合我们的需求，所以我们需要改写一下SQL注入的逻辑；即：逻辑删除的时候，将 delete_time 设置为当前时间戳。\n5、自定义SQL注入器1、自定义逻辑删除，单个删除\npublic class LogicDeleteById extends AbstractMethod &#123;\n\n    /**\n     * mapper 对应的方法名\n     */\n    private static final String MAPPER_METHOD = \"logicDeleteById\";\n\n    @Override\n    public MappedStatement injectMappedStatement(Class&lt;?> mapperClass, Class&lt;?> modelClass, TableInfo tableInfo) &#123;\n        String sql;\n        SqlMethod sqlMethod = SqlMethod.LOGIC_DELETE_BY_ID;\n        if (tableInfo.isLogicDelete()) &#123;\n            List&lt;TableFieldInfo> fieldInfos = tableInfo.getFieldList().stream()\n                    .filter(i -> i.getFieldFill() == FieldFill.UPDATE || i.getFieldFill() == FieldFill.INSERT_UPDATE)\n                    .collect(toList());\n            if (CollectionUtils.isNotEmpty(fieldInfos)) &#123;\n                String sqlSet = \"SET \" + fieldInfos.stream().map(i -> i.getSqlSet(EMPTY)).collect(joining(EMPTY))\n                        + tableInfo.getLogicDeleteSql(false, true)\n                        + \",delete_time = NOW()\";\n                sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), sqlSet, tableInfo.getKeyColumn(),\n                        tableInfo.getKeyProperty(), tableInfo.getLogicDeleteSql(true, false));\n            &#125; else &#123;\n                sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), sqlLogicSet(tableInfo),\n                        tableInfo.getKeyColumn(), tableInfo.getKeyProperty(),\n                        tableInfo.getLogicDeleteSql(true, false));\n            &#125;\n        &#125; else &#123;\n            sqlMethod = SqlMethod.DELETE_BY_ID;\n            sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), tableInfo.getKeyColumn(),\n                    tableInfo.getKeyProperty());\n        &#125;\n        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);\n        return addUpdateMappedStatement(mapperClass, modelClass, MAPPER_METHOD, sqlSource);\n    &#125;\n&#125;\n2、自定义批量逻辑删除\npublic class LogicDeleteBatch extends AbstractMethod &#123;\n\n    /**\n     * mapper 对应的方法名\n     */\n    private static final String MAPPER_METHOD = \"logicDeleteBatch\";\n\n    @Override\n    public MappedStatement injectMappedStatement(Class&lt;?> mapperClass, Class&lt;?> modelClass, TableInfo tableInfo) &#123;\n        String sql;\n        if (tableInfo.isLogicDelete()) &#123;\n            String logicDeleteSql = \"&lt;script>\\nUPDATE %s %s %s\\n&lt;/script>\";\n            List&lt;TableFieldInfo> fieldInfos = tableInfo.getFieldList().stream()\n                    .filter(i -> i.getFieldFill() == FieldFill.UPDATE || i.getFieldFill() == FieldFill.INSERT_UPDATE)\n                    .collect(toList());\n            if (CollectionUtils.isNotEmpty(fieldInfos)) &#123;\n                String sqlSet = \"SET \" + fieldInfos.stream().map(i -> i.getSqlSet(ENTITY_DOT)).collect(joining(EMPTY))\n                        + tableInfo.getLogicDeleteSql(false, true)\n                        + \",delete_time = NOW()\";\n                sql = String.format(logicDeleteSql, tableInfo.getTableName(), sqlSet,\n                        sqlWhereEntityWrapper(true, tableInfo));\n            &#125; else &#123;\n                sql = String.format(logicDeleteSql, tableInfo.getTableName(), sqlLogicSet(tableInfo),\n                        sqlWhereEntityWrapper(true, tableInfo));\n            &#125;\n            SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);\n            return this.addUpdateMappedStatement(mapperClass, modelClass, MAPPER_METHOD, sqlSource);\n        &#125; else &#123;\n            String deleteSql = \"&lt;script>\\nDELETE FROM %s %s\\n&lt;/script>\";\n            sql = String.format(deleteSql, tableInfo.getTableName(), sqlWhereEntityWrapper(true, tableInfo));\n            SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);\n            return this.addDeleteMappedStatement(mapperClass, MAPPER_METHOD, sqlSource);\n        &#125;\n    &#125;\n&#125;\n3、自定义SQL注入器\npublic class MybatisPlusSqlInjector extends DefaultSqlInjector &#123;\n\n    @Override\n    public List&lt;AbstractMethod> getMethodList(Class&lt;?> mapperClass) &#123;\n        // 拿到父类的getMethodList方法\n        List&lt;AbstractMethod> methodList = super.getMethodList(mapperClass);\n\n        // 根据id删除并自动填充 LogicDeleteById\n        methodList.add(new LogicDeleteById());\n\n        methodList.add(new LogicDeleteBatch());\n        return methodList;\n    &#125;\n&#125;\n4、在baseMapper里面声明这两个方法，使用过程中就可以直接在其他mapper中调用这两个自定义方法了：\npublic interface IBaseMapper&lt;T> extends BaseMapper&lt;T> &#123;\n    /**\n     * 逻辑删除\n     *\n     * @param entity\n     * @return\n     */\n    int logicDeleteById(T entity);\n\n    /**\n     * 批量逻辑删除\n     *\n     * @param entity\n     * @param wrapper\n     * @return\n     */\n    int logicDeleteBatch(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T> wrapper);\n&#125;\n6、集成到service层1、接口\npublic interface IBaseService&lt;T> extends IService&lt;T> &#123;\n    /**\n     * 逻辑删除\n     *\n     * @param entity\n     * @return\n     */\n    int logicDeleteById(T entity);\n\n    /**\n     * 批量逻辑删除\n     *\n     * @param entity\n     * @param wrapper\n     * @return\n     */\n    int logicDeleteBatch(T entity, Wrapper&lt;T> wrapper);\n&#125;\n2、实现类，记得要继承ServiceImpl&lt;M, T&gt;，不然要写很多相同的代码\nIBaseServiceImpl.javapublic class IBaseServiceImpl&lt;M extends IBaseMapper&lt;T>, T> extends ServiceImpl&lt;M, T> implements IBaseService&lt;T> &#123;\n\n    @Autowired\n    protected M baseMapper;\n\n    @Override\n    public M getBaseMapper() &#123;\n        return baseMapper;\n    &#125;\n\n    @Override\n    public int logicDeleteById(T entity) &#123;\n        return baseMapper.logicDeleteById(entity);\n    &#125;\n\n    @Override\n    public int logicDeleteBatch(T entity, Wrapper&lt;T> wrapper) &#123;\n        return baseMapper.logicDeleteBatch(entity, wrapper);\n    &#125;\n\n&#125;\n3、至此，就可以在service层进行直接调用了，自从用了mybatis plus，就远离了mapper.xml\n\n","slug":"java/001-mybatis-plus-sql-injector","date":"2022-04-02T05:20:13.000Z","categories_index":"Java","tags_index":"Mybatis Plus,SQL","author_index":"ilobos"},{"id":"15d0f173b74c265bd5670b5b383beb4a","title":"Windows移除快捷方式的小图标","content":"\n1、打开注册表a、Windows图标 + R\nb、输入 regedit 打开注册表编辑程序\n\n2、删除IsShortcuta、依次展开 HKEY_CLASSES_ROOT\\lnkfile ， 也可以直接搜索\nb、找到并右键删除 IsShortcut\n\n3、重启资源管理器a、在任务栏右键，打开 任务管理器， 或使用快捷键 Ctrl + Shift + Esc\nb、依次打开 详细信息 -- 进程\nc、找到 Windows资源管理器，点击右下角的重新启动\n\n4、验收a、回到桌面发现快捷方式的图标已移除\n\n","slug":"win/001-remove-shortcut-flag","date":"2022-03-30T01:20:13.000Z","categories_index":"Windows","tags_index":"shortcut","author_index":"ilobos"},{"id":"a5099e91b4a393d0508ea9911bfe0b64","title":"安装nodejs","content":"\n说明想要使用Electron, 必须要有NodeJS的环境, 所以需要配置好项目环境\n1、下载/升级 NodeJSNodeJS\n安装完成后, 检查版本号是否最最新:\nnode -v\n\n2、升级npmnpm install npm -g\nnpm -v\n\n3、安装cnpmnpm install cnpm -g\n\n4、切换npm镜像源npm config set registry https://registry.npm.taobao.org\n\nnpm config ls","slug":"electron/001-el-nodejs","date":"2022-03-23T12:20:13.000Z","categories_index":"Electron","tags_index":"NodeJS","author_index":"ilobos"},{"id":"edec85881b6b41afd343ca732029f4ed","title":"安装electron","content":"\n说明安装electron 和 electron-packager\n1、安装electroncnpm install electron -g\nelectron -v\n\n2、安装electron-packagercnpm install electron-packager -g\nelectron-packager --version","slug":"electron/002-el-electron","date":"2022-03-23T12:20:13.000Z","categories_index":"Electron","tags_index":"Electron","author_index":"ilobos"},{"id":"3b798228dd0740fc88b22588ebf2648f","title":"使用electron打包exe文件","content":"\n说明Windows首次使用electron-packager打包时耗时很长, 这是因为要下载最新版本的electron文件, 此时我们可以下载好zip文件, 然后通过命令指定, 从而绕过下载的过程\n1、下载资源文件从这里 下载对应的electron的文件\n将对应的文件下载到项目(或一个特定的位置)\n2、更换electron-packager打包命令electron-packager . --electron-zip-dir=../\n\n3、其他参考这里\n","slug":"electron/003-el-electron-exe","date":"2022-03-23T12:20:13.000Z","categories_index":"Electron","tags_index":"exe,Windows,electron-package","author_index":"ilobos"},{"id":"b2874e3fc78ee955cf4b72b9338e5f63","title":"修改Azure的IP","content":"\n说明有些场景，我们需要变更Azure服务器的公共IP地址，这与阿里云、AWS的操作路径不一样，刚开始接触会比较迷糊，遂有此文。\n1、解绑原IP进入服务器所在的【资源组】，点击原IP地址，即可跳转至概述页面，如下图：\n\n  \n\n\n点击【取消关联】，按提示操作即可(上图IP已取消，不能再次点击)。\n2、创建新的IP在任意页面的上方搜索【公共IP地址】，进入下图页面：\n\n  \n\n\n点击【创建公共IP地址】，按页面提示操作即可，如下所示：\n\n  \n\n\n等待数秒，即可看到新IP已就绪：\n\n  \n\n\n3、绑定新IP从资源组点击新IP地址，进入概述页面，如下：\n\n  \n\n\n点击【关联】，在资源类型的地方选择【网络接口】，如下：\n\n  \n\n\n新IP就切换完成啦～\n","slug":"share/002-azure-change-ip","date":"2022-01-23T09:20:13.000Z","categories_index":"Azure","tags_index":"IP","author_index":"ilobos"},{"id":"9916183fe2709503372c397c5ea05887","title":"免费图源-无版权可商用素材站点","content":"\n\n\n\n\n\n\n温馨提示\n本分享仅供个人留档、学习使用，如需商用，使用前请留意对应网站的资源最新使用说明及限制，以免带来不必要的麻烦。\n\n说明在学习、开发过程中，或多或少会需要一些图片；在生活中，或多或少会需要一些高清壁纸，出于对版权的尊重，所以需要一些必要的免费资源，比如本文(本站)的博客封面图，大多来自这些站点，美观简洁、免费大方。\n站点1、PexelsPexels，支持中文搜索，可自由选择图片大小。\n2、PixabayPixabay，海量图源、音视频，且支持中文搜索。\n3、设计之家设计之家，这是一个神奇的网站，适合设计师。\n\n","slug":"share/001-free-pics","date":"2022-01-22T14:20:13.000Z","categories_index":"Design","tags_index":"Free Pics,Design","author_index":"ilobos"},{"id":"7598369c4bfa84f11ee7e6d55697a20e","title":"Aurora个性化配置说明","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hexo/006-hexo-aurora-plus","date":"2022-01-22T08:56:55.000Z","categories_index":"Hexo,Themes,Aurora","tags_index":"Hexo,Aurora","author_index":"ilobos"},{"id":"92d8b63f879f75e2d37b13751be9a4be","title":"Hexo安装Aurora主题","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hexo/005-hexo-aurora","date":"2022-01-22T08:53:55.000Z","categories_index":"Hexo,Themes,Aurora","tags_index":"Hexo,Aurora","author_index":"ilobos"},{"id":"54054c8771f81558e75a10064f187c10","title":"Hexo常用命令行","content":"本文讲述一下hexo的常用命令，相对比较简单。\n1、创建博客hexo new 'my-first-blog'\n\n2、生成静态资源文件hexo generate\n或者\nhexo g\n\n3、部署到本地hexo server\n或者\nhexo s\n\n4、部署到远端hexo deploy\n或者\nhexo d\n\n5、清理静态资源文件hexo clean\n或者\nhexo cl\n\n6、组合命令更为常用6.1、部署本地修改了配置文件，再部署到本地，如果部署到远端则将s换成d\nhexo cl &amp; hexo s -g\n6.2、部署远端修改了配置文件，再部署到远端，如果部署到本地则将d换成s\nhexo d -g","slug":"hexo/004-hexo-cmd","date":"2022-01-21T08:53:55.000Z","categories_index":"Hexo","tags_index":"Hexo,常用命令","author_index":"ilobos"},{"id":"221ff9b73c33c8c7328587ca0c7f4edc","title":"Hexo更换主题(Themes)","content":"\n默认主题是比较丑的，如果有必要，可以尝试官网主题进行更换。\nclone主题找到喜欢的主题，先clone仓库代码，\ngit clone https://github.com/chunqiuyiyu/hexo-theme-polk themes/polk\n执行完成后，会发现themes文件夹多了一个polk的主题文件夹。\n配置主题打开_config.yml文件，修改theme的配置\ntheme: polk\n\n发布主题因为修改了配置文件，则需要clean掉静态资源文件，进行重新生成；此处只演示本地，如果需要发布到远端，将s改成d即可。\nhexo cl &amp; hexo s -g\n","slug":"hexo/003-hexo-themes","date":"2022-01-21T07:38:47.000Z","categories_index":"Hexo,Themes","tags_index":"Hexo,Themes","author_index":"ilobos"},{"id":"238c46f5783213064039b25b694d590e","title":"使用GitHub Pages搭建个人博客","content":"\n\n\n\n\n\n\n温馨提示\n本方案需要搭配Hexo使用，请确保已正确安装Hexo。\n\nGitHub支持创建1、个人/组织，2、已有项目这两种类型的网站。1、想要直接 username.github.io 来访问自己的个人博客，那就需要用到GitHub Pages的服务，对比Gitee则无需进行身份认证，值得说明的是，Gitee需要身份证正反面和手持，介意的话直接使用GitHub Pages的服务即可。2、想要对已有项目进行建站，直接打开Pages的设置即可。\n一、个人/组织 建站创建空仓库创建一个名为 username.github.io 的空仓库(其中username为GitHub的用户名)，该仓库名称敏感即必须保持一致，另外该仓库必须为Public，才能进行有效访问。\n借助【hexo】制作Pages1、将代码克隆到本地，并将【.git】目录暂时移出；\n\n\n\n\n\n\n提示\n此处如果不移出，hexo初始化时会报错，提示当前文件夹为非空。\n\n2、cd到项目里，执行命令初始化项目\nhexo init\n\n\n\n\n\n\n提示\n在项目中执行初始化，对应的配置文件也会在该目录下，方便后续配置其他主题。\n\n3、将【.git】目录移回项目\n4、执行命令部署Pages @本地\nhexo s -g\n\n\n\n\n\n\n本地访问\n1、执行该命令后，hexo会自动创建public的目录，里面保存了html等静态文件，方便后续发布到Github；2、hexo s -g，也可以分成 hexo g #生成代码 和 hexo s #运行服务 两次执行；3、在浏览器输入localhost:4000或点击命令行中的链接直接跳转即可访问到博客主页。\n\n5、部署到Github前的配置当第4步中，本地觉得满意后，则需要打开_config.yml文件，修改部署的deploy配置：\ndeploy:\n  type: git\n  repository: git@github.com:xxx&#x2F;xxx.github.git\n  branch: master\n如果有多个仓库的需求，则需要改成：\ndeploy:\n  type: git\n  repo: \n      github: git@github.com:xxx&#x2F;xxx.github.io.git\n      gitee: https:&#x2F;&#x2F;gitee.com&#x2F;xxx&#x2F;xxx.git\n  branch: master\n\n\n\n\n\n\n提示\n请根据实际情况选择 https 或者 ssh 的仓库地址\n\n6、安装部署插件\n\n\n\n\n\n\n\nDanger\n如果使用hexo d出现如下错误，需执行以下命令安装插件Deployer not found: gitee 或者 Deployer not found: git\n\nnpm install hexo-deployer-git --save\n\n7、执行命令部署Pages @Github\nhexo cl &amp; hexo d -g\n\n\n\n\n\n\nGithub访问\n在浏览器输入 username.github.io 即可访问到博客主页；如果提示404，等待一段时间，待github刷新CDN即可正常访问。\n\n8、创建、修改博客\nhexo new 'my-first-blog'\n会在你的博客文件夹生成，source/_posts/my-first-blog.md 文件，sublime、vscode、Typora等均可修改md文件\n9、发布博客\n本地：\nhexo s -g\n\n远端：\nhexo d -g\n\n\n二、已有项目 建站1、进入已有项目，依次点击【Settings】–&gt;【Pages】，如下图：\n\n  \n\n\n2、在右侧的【Source】选择对应的分支，点击【Save】\n3、最后，在仓库中创建一个index.html然后push就可以啦～\n","slug":"hexo/002-github-pages","date":"2022-01-19T13:20:13.000Z","categories_index":"Hexo,个人博客","tags_index":"GitHub Pages,Blog","author_index":"ilobos"},{"id":"dd134f0a0b193c4f4de61551c33c84e5","title":"Hexo安装说明","content":"为了建立个人博客网站，使用 username.github.io 进行访问，本文将介绍 使用Hexo 这款简单、快速、强大的开源方案在Mac环境下进行建站、发布博客。 \n全局安装使用npm、homebrew命令皆可\nnpm install -g hexo\n\n如果没有nodejs，则需要先安装\nbrew install node\n\n\n\n\n\n\n提示\n安装完成后不要执行其他命令，主要是为了后续的博客项目配置更加简单。\n\n","slug":"hexo/001-hexo-install","date":"2022-01-18T08:53:55.000Z","categories_index":"Hexo,个人博客","tags_index":"Hexo,Mac","author_index":"ilobos"},{"id":"150afb2e14cbc5dc7ea2d3f01d83d0cc","title":"Mac设置别名","content":"\n1、查看别名alias\n\n2、编辑.bash_profile文件vim ~/.bash_profile\n\n3、添加别名语法：alias [别名]=’[指令]’说明：=等号两端无空格、指令两端有单引号举例：\nalias blog&#x3D;&#39;cd &#x2F;Users&#x2F;xxx&#x2F;develop&#x2F;study&#x2F;ilobos.github.io;&#39;\n\n4、生效source ~/.bash_profile\n\n","slug":"mac/001-alias","date":"2021-12-22T14:20:13.000Z","categories_index":"Mac","tags_index":"CMD,Alias","author_index":"ilobos"}]